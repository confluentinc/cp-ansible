# Step 0: Ensure /tmp exists
- name: Ensure /tmp directory exists
  file:
    path: /tmp
    state: directory
    mode: '0755'

- name: Copy PKCS#8 private key to remote host
  copy:
    src: "{{ oauth_client_assertion_private_key_file }}"
    dest: /tmp/private_key_pkcs8.pem
    mode: '0600'
  when:
    - oauth|bool
    - oauth_client_assertion_enabled|bool
    - oauth_client_assertion_private_key_passphrase != 'none'

# Step 1: Convert PEM to PKCS#8 with passphrase or copy as is if no passphrase
- name: Convert PEM to PKCS#8 if passphrase provided
  command: >
    openssl pkcs8 -topk8 -inform PEM -outform PEM
    -in /tmp/private_key_pkcs8.pem
    -out /tmp/oauth_private_key_pkcs8.pem
    -passin pass:{{ oauth_client_assertion_private_key_passphrase }}
    -passout pass:{{ oauth_client_assertion_private_key_passphrase }}
  when:
    - oauth|bool
    - oauth_client_assertion_enabled|bool
    - oauth_client_assertion_private_key_passphrase != 'none'

- name: Copy private key as PEM if no passphrase
  copy:
    src: "{{ oauth_client_assertion_private_key_file }}"
    dest: /tmp/oauth_private_key.pem
    mode: '0600'
  when:
    - oauth|bool
    - oauth_client_assertion_enabled|bool
    - oauth_client_assertion_private_key_passphrase == 'none'

# Step 2: Set path to private key to use for signing
- name: Set private key path
  set_fact:
    oauth_private_key_path: >-
      {{
        '/tmp/oauth_private_key_pkcs8.pem'
        if oauth_client_assertion_private_key_passphrase != 'none'
        else '/tmp/oauth_private_key.pem'
      }}
  when:
    - oauth|bool
    - oauth_client_assertion_enabled|bool

# Step 3: Use third-party JWT assertion if provided (file or variable), else generate locally
- block:
    - name: Read third-party JWT assertion from file
      slurp:
        src: "{{ oauth_client_assertion_file }}"
      register: third_party_assertion
      when: oauth_client_assertion_file != 'none'

    - name: Set client_assertion_jwt from third-party file
      set_fact:
        client_assertion_jwt: "{{ third_party_assertion.content | b64decode }}"
      when: oauth_client_assertion_file != 'none'

  when:
    - oauth|bool
    - oauth_client_assertion_enabled|bool

- block:
    - name: Generate current timestamp
      command: date +%s
      register: current_epoch
      changed_when: false

    - name: Generate JWT claims
      set_fact:
        jwt_claims: >-
          {{
            {
              "iss": oauth_client_assertion_issuer,
              "sub": oauth_client_assertion_sub,
              "aud": oauth_client_assertion_audience,
              "jti": (current_epoch.stdout | string) ~ '-' ~ (100000 | random | string),
              "iat": current_epoch.stdout | int - 5,
              "exp": (current_epoch.stdout | int + 295)
            }
          }}

    - name: Create JWT header and payload
      set_fact:
        jwt_header: '{{ {"alg": "RS256", "typ": "JWT"} | to_json | b64encode }}'
        jwt_payload: '{{ jwt_claims | to_json | b64encode }}'

    - name: Create JWT signing input
      set_fact:
        jwt_signing_input: "{{ jwt_header }}.{{ jwt_payload }}"

    - name: Write JWT signing input to file
      copy:
        dest: /tmp/jwt_input.txt
        content: "{{ jwt_signing_input }}"

    - name: Sign JWT using OpenSSL with passphrase
      command: >
        openssl dgst -sha256
        -sign {{ oauth_private_key_path }}
        -passin pass:{{ oauth_client_assertion_private_key_passphrase }}
        -out /tmp/jwt.sig
        /tmp/jwt_input.txt
      when: oauth|bool and oauth_client_assertion_enabled|bool and oauth_client_assertion_private_key_passphrase != 'none'

    - name: Sign JWT using OpenSSL without passphrase
      command: >
        openssl dgst -sha256
        -sign {{ oauth_private_key_path }}
        -out /tmp/jwt.sig
        /tmp/jwt_input.txt
      when: oauth|bool and oauth_client_assertion_enabled|bool and ( oauth_client_assertion_private_key_passphrase == 'none')

    - name: Read JWT signature
      slurp:
        src: /tmp/jwt.sig
      register: jwt_sig

    - name: Encode JWT signature to base64url
      set_fact:
        jwt_signature: "{{ jwt_sig.content | b64decode | b64encode | regex_replace('\\+', '-') | regex_replace('/', '_') | regex_replace('=+$', '') }}"

    - name: Combine final JWT
      set_fact:
        client_assertion_jwt: "{{ jwt_signing_input }}.{{ jwt_signature }}"

  when:
    - oauth|bool
    - oauth_client_assertion_enabled|bool
    - oauth_client_assertion_file == 'none'  # Only generate if no third-party JWT

# Step 4: Prepare token request body
- set_fact:
    idp_body: >-
      {{
        [
          ['grant_type', 'client_credentials']
        ]
        + (
            [['scope', oauth_groups_scope]]
            if oauth_groups_scope != 'none' else []
          )
        + (
            [
              ['client_assertion_type', 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer'],
              ['client_assertion', client_assertion_jwt]
            ]
            if oauth_client_assertion_enabled | default(false) else
            [
              ['client_id', oauth_user],
              ['client_secret', oauth_password]
            ]
          )
      }}
  when: oauth | bool

# Step 5: Send token request
- name: Get Authorization Token from Identity Provider (OAuth)
  uri:
    url: "{{ oauth_token_uri }}"
    method: POST
    validate_certs: false
    return_content: true
    status_code: 200
    headers:
      Content-Type: application/x-www-form-urlencoded
    body_format: form-urlencoded
    body: "{{ idp_body }}"
  register: auth_token_oauth
  until: auth_token_oauth.status == 200
  retries: 10
  delay: 5
  no_log: "{{mask_secrets|bool}}"
  when:
    - oauth|bool
    - not cert_auth_only_enabled|bool

- name: Get Authorization Token from MDS
  uri:
    url: "{{mds_bootstrap_server_urls.split(',')[0]}}/security/1.0/authenticate"
    method: GET
    validate_certs: false
    return_content: true
    status_code: 200
    url_username: "{{ldap_user}}"
    url_password: "{{ldap_password}}"
    client_cert: "{{ mtls_client_cert if send_client_cert|bool else omit }}"
    client_key: "{{ mtls_client_key if send_client_cert|bool else omit }}"
    force_basic_auth: true
  register: auth_token_mds
  until: auth_token_mds.status == 200
  retries: "{{ mds_retries }}"
  delay: 5
  no_log: "{{mask_secrets|bool}}"
  when:
    - cluster_id_source | default('erp') == 'erp'
    - not oauth|bool
    - auth_mode != 'mtls'
    - not cert_auth_only_enabled|bool

- name: Get Authorization Token from MDS using mtls certs
  uri:
    url: "{{mds_bootstrap_server_urls.split(',')[0]}}/security/1.0/authenticate"
    method: GET
    validate_certs: false
    return_content: true
    status_code: 200
    force_basic_auth: false
    client_cert: "{{ mtls_client_cert if send_client_cert|bool else omit }}"
    client_key: "{{ mtls_client_key if send_client_cert|bool else omit }}"
  register: auth_token_mds_mtls
  until: auth_token_mds_mtls.status == 200
  retries: "{{ mds_retries }}"
  delay: 5
  no_log: "{{mask_secrets|bool}}"
  when:
    - cluster_id_source | default('erp') == 'erp'
    - auth_mode == 'mtls' or cert_auth_only_enabled|bool

# Step 6: Set the authorization_token from whichever token source is applicable
- name: Set Authorization Token
  set_fact:
    authorization_token: >-
      {%- if oauth|bool and not cert_auth_only_enabled|bool -%}
        {{ (auth_token_oauth.content | from_json).access_token }}
      {%- elif not oauth|bool and auth_mode != 'mtls' and not cert_auth_only_enabled|bool -%}
        {{ (auth_token_mds.content | from_json).auth_token }}
      {%- elif auth_mode == 'mtls' or cert_auth_only_enabled|bool -%}
        {{ (auth_token_mds_mtls.content | from_json).auth_token }}
      {%- endif -%}
  no_log: "{{mask_secrets|bool}}"