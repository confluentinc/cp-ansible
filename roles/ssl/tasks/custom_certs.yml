---
- name: Copy CA Cert to Host
  copy:
    remote_src: "{{ssl_custom_certs_remote_src}}"
    src: "{{ssl_ca_cert_filepath}}"
    dest: "{{ca_cert_path}}"
  diff: "{{ not mask_sensitive_diff|bool }}"

- name: Copy Signed Cert to Host
  copy:
    remote_src: "{{ssl_custom_certs_remote_src}}"
    src: "{{ssl_signed_cert_filepath}}"
    dest: "{{ cert_path }}"

- name: Create temp directory for individual certificates
  tempfile:
    state: directory
    suffix: individual_certs
  register: temp_dir

- name: Split CA Cert Bundle into Individual Certificates
  shell: |
    awk 'BEGIN {n=0} /BEGIN CERTIFICATE/{n++} {print > "{{ temp_dir.path }}/ca." n ".pem"}' {{ ca_cert_path }}
  changed_when: false

- name: Split Signed Cert Bundle - Extract Last Certificate
  shell: |
    awk '
      /BEGIN CERTIFICATE/,/END CERTIFICATE/ {
        cert = cert $0 "\n"
      }
      /END CERTIFICATE/ {
        last_cert = cert
        cert = ""
      }
      END {
        print last_cert
      }' {{ cert_path }} > "{{ temp_dir.path }}/signed.last.pem"
  changed_when: false

- name: Verify and Build Certificate Chain
  shell: |
    for ca_file in {{ temp_dir.path }}/ca.*.pem; do
      # Verify using the last certificate from the chain
      if openssl verify -CAfile "$ca_file" "{{ temp_dir.path }}/signed.last.pem"; then
        # If verification succeeds, create the chain using original cert/chain
        cat {{ cert_path }} "$ca_file" > "{{ ssl_file_dir_final }}/{{ service_name }}.chain"
        echo "Chain completed with: $ca_file"
        exit 0
      fi
    done
    echo "No valid CA found to complete the chain" >&2
    exit 1
  register: chain_result
  failed_when: chain_result.rc != 0
  changed_when: chain_result.rc == 0

- name: Cleanup Temp Directory
  file:
    path: "{{ temp_dir.path }}"
    state: absent
  changed_when: false

- name: Copy Key to Host
  copy:
    remote_src: "{{ssl_custom_certs_remote_src}}"
    src: "{{ssl_key_filepath}}"
    dest: "{{ ssl_file_dir_final }}/generation/{{service_name}}.key"
  diff: "{{ not mask_sensitive_diff|bool }}"

- name: Load Private Key
  slurp:
    src: "{{ ssl_file_dir_final }}/generation/{{service_name}}.key"
  register: slurped_private_key
  diff: "{{ not mask_sensitive_diff|bool }}"

- name: Copy Key to Final Location - Non Encrypted
  copy:
    remote_src: true
    src: "{{ ssl_file_dir_final }}/generation/{{service_name}}.key"
    dest: "{{key_path}}"
  when: "'BEGIN ENCRYPTED PRIVATE KEY' not in slurped_private_key.content|b64decode"
  diff: "{{ not mask_sensitive_diff|bool }}"

- name: Create Non Encrypted Private Key
  shell: |
    openssl rsa -in {{ ssl_file_dir_final }}/generation/{{service_name}}.key \
      -out {{key_path}} {% if ssl_key_password is defined %}-passin pass:{{ssl_key_password}} -passout pass:{{ssl_key_password}}{% endif %}
  when: "'ENCRYPTED' in slurped_private_key.content|b64decode"
  no_log: "{{mask_secrets|bool}}"

- name: Create Keystore and Truststore from Certs
  include_tasks: create_keystores_from_certs.yml
