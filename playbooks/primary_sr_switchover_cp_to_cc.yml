---
# Schema Registry Automation Workflow
#
# This playbook supports Ansible tags for selective execution:
#   ansible-playbook playbook.yml --tags "schema_export"     # Run only schema export
#   ansible-playbook playbook.yml --tags "switchover"       # Run only switchover
#   ansible-playbook playbook.yml --tags "reverse_sync"     # Run only reverse sync
#   ansible-playbook playbook.yml --tags "schema_export,switchover"  # Run multiple phases
#   ansible-playbook playbook.yml --skip-tags "reverse_sync"        # Skip reverse sync
#   ansible-playbook playbook.yml                           # Run all (default)
#
# Available tags:
#   - validate: Pre-flight validation
#   - check_status: Check existing exporter status
#   - schema_export: Setup schema exporter
#   - switchover: Perform SR switchover
#   - reverse_sync: Setup schema importer

- name: Schema Registry Automation Workflow
  hosts: schema_registry
  gather_facts: false
  vars:
    # Workflow control variables
    workflow_part: "{{ workflow_part | default('all') }}"  # Options: schema_export, switchover, reverse_sync, all

    # Status tracking
    workflow_status: "started"
    failed_step: ""

  tasks:
    - import_role:
        name: variables

    - name: Check if automation workflow should run
      set_fact:
        run_automation_workflow: "{{ sr_switch_over_exporter_name is defined and sr_switch_over_exporter_name != '' and sr_switch_over_exporter_name != 'none' }}"

    - name: Skip automation workflow
      debug:
        msg: |
          Skipping Schema Registry switchover automation workflow.
          Reason: sr_switch_over_exporter_name is not defined or empty.
          To enable automation, define sr_switch_over_exporter_name with a valid exporter name.
      when: not (run_automation_workflow | bool)

    - name: Validate automation workflow configuration
      assert:
        that:
          - unified_stream_manager is defined
          - schema_importers is defined
        fail_msg: "Schema registry automation configuration is missing required fields"
      when: run_automation_workflow | bool
      tags: validate

    # Ensure schema registry is configured with required automation properties
    - name: "Configure Schema Registry for Automation"
      block:
        - name: Configure schema registry with required automation properties
          debug:
            msg: |
              Configuring Schema Registry with automation properties (will create or update existing configuration).
              Required properties for exporter/importer functionality:
              - kafkastore.update.handlers=io.confluent.schema.exporter.storage.SchemaExporterUpdateHandler
              - schema.registry.resource.extension.class=...SchemaExporterResourceExtension,SchemaImporterResourceExtension...
              - password.encoder.secret={{ password_encoder_secret | default('***') }}
              {% if unified_stream_manager is defined and unified_stream_manager.remote_schema_registry_endpoint != 'none' %}
              USM Properties (for Confluent Cloud integration):
              - usm.schema.registry.remote.endpoint={{ unified_stream_manager.remote_schema_registry_endpoint }}
              - usm.schema.registry.remote.api.key={{ unified_stream_manager.basic_username }}
              - usm.schema.registry.remote.api.secret=***
              {% endif %}
              {% if unified_stream_manager is defined and unified_stream_manager.remote_context is defined and unified_stream_manager.remote_context != '' %}
              - usm.schema.registry.remote.context.prefix={{ unified_stream_manager.remote_context }}
              {% endif %}

        - name: Add/Update required automation properties to schema registry config
          blockinfile:
            path: "{{ schema_registry.config_file }}"
            block: |
              # Schema Registry Automation Properties
              kafkastore.update.handlers=io.confluent.schema.exporter.storage.SchemaExporterUpdateHandler
              schema.registry.resource.extension.class={{ rbac_enabled | confluent.platform.schema_registry_extension_classes(schema_exporters is defined, schema_importers is defined, (unified_stream_manager is defined and unified_stream_manager.remote_schema_registry_endpoint != 'none')) }}
              password.encoder.secret={{ password_encoder_secret }}
              {% if unified_stream_manager is defined and unified_stream_manager.remote_schema_registry_endpoint != 'none' %}
              # USM Schema Registry Properties
              usm.schema.registry.remote.endpoint={{ unified_stream_manager.remote_schema_registry_endpoint }}
              usm.schema.registry.remote.api.key={{ unified_stream_manager.basic_username }}
              usm.schema.registry.remote.api.secret={{ unified_stream_manager.basic_password }}
              {% endif %}
              {% if unified_stream_manager is defined and unified_stream_manager.remote_context is defined and unified_stream_manager.remote_context != '' %}
              # USM Context Prefix Properties
              usm.schema.registry.remote.context.prefix={{ unified_stream_manager.remote_context }}
              {% endif %}
            marker: "# {mark} ANSIBLE MANAGED BLOCK - Schema Registry Automation"
            backup: yes
          register: automation_properties_added
          when: 
            - not (skip_part1 | default(false))

        - name: Restart schema registry if properties were added
          systemd:
            name: "{{ schema_registry_service_name }}"
            state: restarted
          when: 
            - not (skip_part1 | default(false))
            - automation_properties_added is defined
            - automation_properties_added.changed

        - name: Wait for Schema Registry to be ready after reconfiguration
          uri:
            url: "{{ schema_registry_http_protocol }}://{{ inventory_hostname }}:{{ schema_registry_listener_port }}/subjects"
            method: GET
            status_code: 200
            validate_certs: false
            user: "{{ schema_registry_health_check_user if schema_registry_authentication_type == 'basic' else omit }}"
            password: "{{ schema_registry_health_check_password if schema_registry_authentication_type == 'basic' else omit }}"
          retries: 30
          delay: 5
          when: 
            - not (skip_part1 | default(false))
            - automation_properties_added is defined
            - automation_properties_added.changed

      when: run_automation_workflow | bool

    # Check if exporter already exists and is running (pilot mode)
    - name: "Check existing exporter status"
      block:
        - name: Check if specific exporter is already running
          uri:
            url: "{{ schema_registry_http_protocol }}://{{ inventory_hostname }}:{{ schema_registry_listener_port }}/exporters/{{ sr_switch_over_exporter_name }}/status"
            method: GET
            status_code: 200
            validate_certs: false
            user: "{{ schema_registry_health_check_user if schema_registry_authentication_type == 'basic' else omit }}"
            password: "{{ schema_registry_health_check_password if schema_registry_authentication_type == 'basic' else omit }}"
          register: existing_exporter_status
          failed_when: false
          when: sr_switch_over_exporter_name is defined

        - name: Log existing exporter status
          debug:
            msg: "Exporter {{ sr_switch_over_exporter_name }} found with state: {{ existing_exporter_status.json.state | default('NOT_FOUND') }}"
          when:
            - sr_switch_over_exporter_name is defined
            - existing_exporter_status.status == 200

        - name: Set skip_schema_export flag if exporter is already running
          set_fact:
            skip_schema_export: true
          when:
            - sr_switch_over_exporter_name is defined
            - existing_exporter_status.status == 200
            - existing_exporter_status.json.state == 'RUNNING'

        - name: Log skipping Schema Export
          debug:
            msg: "Exporter {{ sr_switch_over_exporter_name }} is already running. Skipping Schema Export Setup."
          when: skip_schema_export | default(false)

      rescue:
        - name: Handle exporter check failure
          debug:
            msg: "Could not check exporter status or exporter not found. Proceeding with Schema Export."

        - name: Set skip_schema_export to false on check failure
          set_fact:
            skip_schema_export: false
      when: run_automation_workflow | bool

    # SCHEMA EXPORT: Export existing CP schemas to CC
    - name: "Schema Export: Setup Schema Exporter on CP SR"
      block:
        - name: Setup Schema Exporter
          include_role:
            name: schema_exporter

        - name: Determine exporter name for status check
          set_fact:
            exporter_name: "{{ sr_switch_over_exporter_name | default(schema_exporters[0].name) }}"

        - name: Wait for Schema Exporter to be in Running state
          uri:
            url: "{{ schema_registry_http_protocol }}://{{ inventory_hostname }}:{{ schema_registry_listener_port }}/exporters/{{ exporter_name }}/status"
            method: GET
            status_code: 200
            validate_certs: false
            user: "{{ schema_registry_health_check_user if schema_registry_authentication_type == 'basic' else omit }}"
            password: "{{ schema_registry_health_check_password if schema_registry_authentication_type == 'basic' else omit }}"
          register: exporter_status_check
          until: exporter_status_check.json.state == 'RUNNING'
          retries: 30
          delay: 10

        - name: Verify exporter is running
          assert:
            that:
              - exporter_status_check.json.state == 'RUNNING'
            fail_msg: "Schema Exporter failed to reach RUNNING state. Current state: {{ exporter_status_check.json.state }}"

      rescue:
        - name: Handle Schema Export failure
          set_fact:
            failed_step: "schema_export_setup"
            workflow_status: "failed"

        - name: Fail workflow
          fail:
            msg: "Schema Export failed. Cannot proceed with automation."
      when:
        - run_automation_workflow | bool
        - workflow_part in ['schema_export', 'all']
        - not (skip_schema_export | default(false))
      tags:
        - schema_export

    # SWITCHOVER: Primary SR switchover from CP to CC
    - name: "Switchover: Primary SR switchover from CP to CC"
      block:
        - name: Set exporter name for operations
          set_fact:
            exporter_name: "{{ sr_switch_over_exporter_name | default(schema_exporters[0].name) }}"

        - name: Pre-checks - Validate destination URLs match
          assert:
            that:
              - schema_exporters[0].config.remote_schema_registry_endpoint == unified_stream_manager.remote_schema_registry_endpoint
              - schema_importers[0].config.remote_schema_registry_endpoint == unified_stream_manager.remote_schema_registry_endpoint
            fail_msg: "Pre-check failed: Exporter, Importer, and USM remote endpoints must match"

        - name: "Switch CP SR to FORWARD mode (WRITE DOWNTIME STARTS)"
          uri:
            url: "{{ schema_registry_http_protocol }}://{{ inventory_hostname }}:{{ schema_registry_listener_port }}/mode/:.__GLOBAL:"
            method: PUT
            body_format: json
            body:
              mode: "FORWARD"
            status_code: 200
            validate_certs: false
            user: "{{ schema_registry_health_check_user if schema_registry_authentication_type == 'basic' else omit }}"
            password: "{{ schema_registry_health_check_password if schema_registry_authentication_type == 'basic' else omit }}"
          register: cp_sr_forward_mode

        - name: Verify CP SR is in FORWARD mode
          uri:
            url: "{{ schema_registry_http_protocol }}://{{ inventory_hostname }}:{{ schema_registry_listener_port }}/mode/:.__GLOBAL:"
            method: GET
            status_code: 200
            validate_certs: false
            user: "{{ schema_registry_health_check_user if schema_registry_authentication_type == 'basic' else omit }}"
            password: "{{ schema_registry_health_check_password if schema_registry_authentication_type == 'basic' else omit }}"
          register: cp_sr_mode_check
          until: cp_sr_mode_check.json.mode == 'FORWARD'
          retries: 5
          delay: 2

        - name: "Switch CC SR to READWRITE mode (WRITE DOWNTIME ENDS)"
          uri:
            url: "{{ unified_stream_manager.remote_schema_registry_endpoint }}/mode"
            method: PUT
            body_format: json
            body:
              mode: "READWRITE"
            status_code: 200
            validate_certs: false
            user: "{{ unified_stream_manager.basic_username if unified_stream_manager.remote_authentication_type == 'basic' else omit }}"
            password: "{{ unified_stream_manager.basic_password if unified_stream_manager.remote_authentication_type == 'basic' else omit }}"
          register: cc_sr_readwrite_mode

        - name: Verify CC SR is in READWRITE mode
          uri:
            url: "{{ unified_stream_manager.remote_schema_registry_endpoint }}/mode"
            method: GET
            status_code: 200
            validate_certs: false
            user: "{{ unified_stream_manager.basic_username if unified_stream_manager.remote_authentication_type == 'basic' else omit }}"
            password: "{{ unified_stream_manager.basic_password if unified_stream_manager.remote_authentication_type == 'basic' else omit }}"
          register: cc_sr_mode_check
          until: cc_sr_mode_check.json.mode == 'READWRITE'
          retries: 5
          delay: 2

      rescue:
        - name: Handle Switchover failure
          set_fact:
            failed_step: "primary_switchover"
            workflow_status: "failed"

        - name: "ROLLBACK: Restore CP SR to READWRITE mode"
          uri:
            url: "{{ schema_registry_http_protocol }}://{{ inventory_hostname }}:{{ schema_registry_listener_port }}/mode/:.__GLOBAL:"
            method: PUT
            body_format: json
            body:
              mode: "READWRITE"
            status_code: 200
            validate_certs: false
            user: "{{ schema_registry_health_check_user if schema_registry_authentication_type == 'basic' else omit }}"
            password: "{{ schema_registry_health_check_password if schema_registry_authentication_type == 'basic' else omit }}"
          ignore_errors: true

        - name: Fail workflow with rollback info
          fail:
            msg: |
              Primary Switchover failed.
              Rollback attempted: CP SR restored to READWRITE mode.
              Manual intervention may be required.
      when:
        - run_automation_workflow | bool
        - (workflow_part in ['switchover', 'all'] or (skip_schema_export | default(false)))
      tags:
        - switchover

    # REVERSE SYNC: Setup Schema Importer for reverse sync
    - name: "Reverse Sync: Setup Schema Importer"
      block:
        - name: Setup Schema Importer
          include_role:
            name: schema_importer

        - name: Wait for Schema Importer to be in Running state
          uri:
            url: "{{ schema_registry_http_protocol }}://{{ inventory_hostname }}:{{ schema_registry_listener_port }}/importers/{{ schema_importers[0].name }}/status"
            method: GET
            status_code: 200
            validate_certs: false
            user: "{{ schema_registry_health_check_user if schema_registry_authentication_type == 'basic' else omit }}"
            password: "{{ schema_registry_health_check_password if schema_registry_authentication_type == 'basic' else omit }}"
          register: importer_status_check
          until: importer_status_check.json.state == 'RUNNING'
          retries: 30
          delay: 10

        - name: Verify importer is running
          assert:
            that:
              - importer_status_check.json.state == 'RUNNING'
            fail_msg: "Schema Importer failed to reach RUNNING state. Current state: {{ importer_status_check.json.state }}"

        - name: Log automation completion
          debug:
            msg: |
              SR AUTOMATION WORKFLOW COMPLETED SUCCESSFULLY!

              Current State:
              - Primary SR: CC SR ({{ unified_stream_manager.remote_schema_registry_endpoint }})
              - CP SR: FORWARD mode → CC SR
              - Export Sync: CP SR → CC SR ({{ schema_exporters[0].name }})
              - Import Sync: CC SR → CP SR ({{ schema_importers[0].name }})

              Next Steps:
              - Monitor importer/exporter status regularly
              - Update applications to use CC SR endpoint
              - Verify schema compatibility and data flow

      rescue:
        - name: Handle Reverse Sync failure
          set_fact:
            failed_step: "reverse_sync_setup"
            workflow_status: "failed"

        - name: Fail workflow
          fail:
            msg: "Reverse Sync failed. Manual intervention required for importer setup."
      when:
        - run_automation_workflow | bool
        - workflow_part in ['reverse_sync', 'all']
      tags:
        - reverse_sync

    - name: Display workflow summary
      debug:
        msg: |
          Schema Registry Automation Workflow Summary:
          Status: {{ workflow_status }}
          Parts Executed: {{ workflow_part }}
          {% if failed_step != '' %}
          Failed Step: {{ failed_step }}
          {% endif %}
      when: run_automation_workflow | bool
